{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The Galactic Radio Explorer Telescope Welcome to the documentation for the Galactic Radio Explorer Telescope! In the tabs above, you'll find the documentation for the hardware and software architectures as well as guides for construction and setup. These docs are a WIP and once we deploy, contributions are welcome!","title":"Home"},{"location":"#the-galactic-radio-explorer-telescope","text":"Welcome to the documentation for the Galactic Radio Explorer Telescope! In the tabs above, you'll find the documentation for the hardware and software architectures as well as guides for construction and setup. These docs are a WIP and once we deploy, contributions are welcome!","title":"The Galactic Radio Explorer Telescope"},{"location":"about/","text":"The Galactic Radio Telescope is an new low-cost radio telescope designed to be an all-sky monitor for bright radio bursts. Building on the success of STARE2, we will search for fast radio bursts (FRBs) emitted from Galactic magnetars as well as bursts from nearby galaxies. GReX will search down to ten microseconds time resolution, allowing us to find new super giant radio pulses from Milky Way pulsars and study their broadband emission. The proposed instrument will employ ultra-wide band (0.7-2 GHz) feeds coupled to a high performance (receiver temperature 10 K) low noise amplifier (LNA) originally developed for the DSA-110 and DSA-2000 projects. In GReX Phase I (GReX-I), unit systems will be deployed at Owens Valley Radio Observatory (OVRO) and Big Smoky Valley, Nevada. Phase II will expand the array, placing feeds in India, Australia, and elsewhere in order to build up to continuous coverage of nearly 4\u03c0 steradians and to increase our exposure to the Galactic plane. We model the local magnetar population to forecast for GReX, finding the improved sensitivity and increased exposure to the Galactic plane could lead to dozens of FRB-like bursts per year. For more information, read our paper here ! Team Project Scientist - Dr. Liam Connor, PhD Project Engineer - Kiran Shila, MSEE","title":"About"},{"location":"about/#team","text":"Project Scientist - Dr. Liam Connor, PhD Project Engineer - Kiran Shila, MSEE","title":"Team"},{"location":"hardware/assembly/","text":"Assembly Guide TODO! Once we have the complete pacakge, write a step by step guide for assembly and installation","title":"Assembly Guide"},{"location":"hardware/assembly/#assembly-guide","text":"TODO! Once we have the complete pacakge, write a step by step guide for assembly and installation","title":"Assembly Guide"},{"location":"hardware/box/","text":"The Box TODO! Once the box is done, document cables, routing, etc.","title":"The Box"},{"location":"hardware/box/#the-box","text":"TODO! Once the box is done, document cables, routing, etc.","title":"The Box"},{"location":"hardware/feed/","text":"Feed Antenna TODO! Jonas info","title":"Feed Antenna"},{"location":"hardware/feed/#feed-antenna","text":"TODO! Jonas info","title":"Feed Antenna"},{"location":"hardware/fem/","text":"Frontend Module The frontend module (FEM) is a device that performs the analog signal processing after the LNAs. This includes filtering, downconversion, and amplification. Additionally, this module provides rudimentary monitor and control support. Bare PCB Completed Module Hardware Design The hardware design itself is implemented in the free KiCAD program and is available here . To manufacture from gerber files, the stackup needs to be JLC7628 from JLCPCB. The current hardware uses ENIG to help reflow of the fine-pitch components. Schematics BOM Case Firmware Design The RF hardware mostly operates without the intervention of any software. The only step required to use the RF hardware is to set the valid attenuation level, which defaults to 0 dB. As such, the primary goal of the digital section of the FEM is to perform Monitor and Control (MnC). MnC is achieved via an 115200 baud 3.3V UART interface on the main connector. The firmware design is carried out in the Rust programming language, and whose source can be found here . Monitor Every 1 second on UART (115200 baud), JSON payload of monitor data is sent out with the following schema { \"boardTemp\" : 29.6 , \"voltages\" : { \"rawInput\" : 6.2 , \"analog\" : 4.9 , \"lnaOne\" : 5.3 , \"lnaTwo\" : 5.3 }, \"currents\" : { \"rawInput\" : 0.723 , \"analog\" : 0.53 , \"lnaOne\" : 0.053 , \"lnaTwo\" : 0.052 }, \"ifPower\" : { \"channelOne\" : -0.3 , \"channelTwo\" : -2.1 }, \"control\" : { \"calOne\" : false , \"calTwo\" : false , \"lnaOnePowered\" : true , \"lnaTwoPowered\" : true , \"attenuationLevel\" : 3 , \"ifPowerThreshold\" : -10 } } Control The control payload must be a complete JSON object of the following form: { \"control\" : { \"calOne\" : false , \"calTwo\" : false , \"lnaOnePowered\" : true , \"lnaTwoPowered\" : true , \"attenuationLevel\" : 3 , \"ifPowerThreshold\" : -10 } } Over UART, there is control for enabling/disabling the calibration output, the LNA bias, and the interstage IF attenuator. For the digital attenuator, there are four levels (0-3), representing 0, 4, 8, 12 dB. This attenuator is to maximize the dynamic range of the ADC and can be set for environmental RFI levels. Physical Interface There are eight LEDs on the front panel. Four red LEDs to indicate power statess, two blue LEDs for serial activity, and two green LEDs for system status. The green LEDs will be enabled when the IF power is at a nominal level and will flash when the calibration signal is enabled.","title":"Fronend Module"},{"location":"hardware/fem/#frontend-module","text":"The frontend module (FEM) is a device that performs the analog signal processing after the LNAs. This includes filtering, downconversion, and amplification. Additionally, this module provides rudimentary monitor and control support. Bare PCB Completed Module","title":"Frontend Module"},{"location":"hardware/fem/#hardware-design","text":"The hardware design itself is implemented in the free KiCAD program and is available here . To manufacture from gerber files, the stackup needs to be JLC7628 from JLCPCB. The current hardware uses ENIG to help reflow of the fine-pitch components. Schematics BOM Case","title":"Hardware Design"},{"location":"hardware/fem/#firmware-design","text":"The RF hardware mostly operates without the intervention of any software. The only step required to use the RF hardware is to set the valid attenuation level, which defaults to 0 dB. As such, the primary goal of the digital section of the FEM is to perform Monitor and Control (MnC). MnC is achieved via an 115200 baud 3.3V UART interface on the main connector. The firmware design is carried out in the Rust programming language, and whose source can be found here .","title":"Firmware Design"},{"location":"hardware/fem/#monitor","text":"Every 1 second on UART (115200 baud), JSON payload of monitor data is sent out with the following schema { \"boardTemp\" : 29.6 , \"voltages\" : { \"rawInput\" : 6.2 , \"analog\" : 4.9 , \"lnaOne\" : 5.3 , \"lnaTwo\" : 5.3 }, \"currents\" : { \"rawInput\" : 0.723 , \"analog\" : 0.53 , \"lnaOne\" : 0.053 , \"lnaTwo\" : 0.052 }, \"ifPower\" : { \"channelOne\" : -0.3 , \"channelTwo\" : -2.1 }, \"control\" : { \"calOne\" : false , \"calTwo\" : false , \"lnaOnePowered\" : true , \"lnaTwoPowered\" : true , \"attenuationLevel\" : 3 , \"ifPowerThreshold\" : -10 } }","title":"Monitor"},{"location":"hardware/fem/#control","text":"The control payload must be a complete JSON object of the following form: { \"control\" : { \"calOne\" : false , \"calTwo\" : false , \"lnaOnePowered\" : true , \"lnaTwoPowered\" : true , \"attenuationLevel\" : 3 , \"ifPowerThreshold\" : -10 } } Over UART, there is control for enabling/disabling the calibration output, the LNA bias, and the interstage IF attenuator. For the digital attenuator, there are four levels (0-3), representing 0, 4, 8, 12 dB. This attenuator is to maximize the dynamic range of the ADC and can be set for environmental RFI levels.","title":"Control"},{"location":"hardware/fem/#physical-interface","text":"There are eight LEDs on the front panel. Four red LEDs to indicate power statess, two blue LEDs for serial activity, and two green LEDs for system status. The green LEDs will be enabled when the IF power is at a nominal level and will flash when the calibration signal is enabled.","title":"Physical Interface"},{"location":"hardware/fpga/","text":"Digital Backend TODO! Describe hardware interfaces of SNAP.","title":"Digital Backend"},{"location":"hardware/fpga/#digital-backend","text":"TODO! Describe hardware interfaces of SNAP.","title":"Digital Backend"},{"location":"hardware/overview/","text":"Hardware Overview The GReX hardware system has several \"top level\" components, which constitute the entire system. These include the feed antenna and low noise amplifiers (LNA), the frontend module , the digital backend , and of course the server. The following diagrams lay out general overview of the interconnections. Showing them all at once would be a bit much, so they're broken down here into discrete kinds of signals. RF Signal Path flowchart TD A[Feed] B[FEM] C[SNAP] D[Server] A --> L1[LNA] A --> L2[LNA] L1 -->|H Pol| B L2 -->|V Pol| B subgraph The Box B -->|H Pol| C B -->|V Pol| C end C -->|10 GbE| D[Server] Power Distribution flowchart BT L1[LNA] L2[LNA] B[FEM] C[SNAP] S[Switching Supply] R[Linear Regulator] P[Raspberry Pi] M[Mains Power] V[Synthesizer] G[GPS Receiver] M -->|120-240V AC| S subgraph The Box R -->|6.5V DC| V P -->|\"5V DC (USB)\"| G S -->|12V DC| C S -->|12V DC| R R -->|6.5V DC| B C -->|5V DC| P end B --->|5.5V DC| L1 B --->|5.5V DC| L2 Clocks, References and Timing flowchart BT B[FEM] V[Synthesizer] G[GPS Receiver] S[SNAP] A[GPS Antenna] subgraph The Box G -->|10 MHz| V G -->|PPS| S V -->|250 MHz| S V -->|1030 MHz| B end A --> G Monitor and Control flowchart TB B[FEM] S[SNAP] P[Raspberry Pi] D[Server] subgraph The Box P <-->|UART| B S <-->|GPIO| P end P <--->|1 GbE| D","title":"Overview"},{"location":"hardware/overview/#hardware-overview","text":"The GReX hardware system has several \"top level\" components, which constitute the entire system. These include the feed antenna and low noise amplifiers (LNA), the frontend module , the digital backend , and of course the server. The following diagrams lay out general overview of the interconnections. Showing them all at once would be a bit much, so they're broken down here into discrete kinds of signals.","title":"Hardware Overview"},{"location":"hardware/overview/#rf-signal-path","text":"flowchart TD A[Feed] B[FEM] C[SNAP] D[Server] A --> L1[LNA] A --> L2[LNA] L1 -->|H Pol| B L2 -->|V Pol| B subgraph The Box B -->|H Pol| C B -->|V Pol| C end C -->|10 GbE| D[Server]","title":"RF Signal Path"},{"location":"hardware/overview/#power-distribution","text":"flowchart BT L1[LNA] L2[LNA] B[FEM] C[SNAP] S[Switching Supply] R[Linear Regulator] P[Raspberry Pi] M[Mains Power] V[Synthesizer] G[GPS Receiver] M -->|120-240V AC| S subgraph The Box R -->|6.5V DC| V P -->|\"5V DC (USB)\"| G S -->|12V DC| C S -->|12V DC| R R -->|6.5V DC| B C -->|5V DC| P end B --->|5.5V DC| L1 B --->|5.5V DC| L2","title":"Power Distribution"},{"location":"hardware/overview/#clocks-references-and-timing","text":"flowchart BT B[FEM] V[Synthesizer] G[GPS Receiver] S[SNAP] A[GPS Antenna] subgraph The Box G -->|10 MHz| V G -->|PPS| S V -->|250 MHz| S V -->|1030 MHz| B end A --> G","title":"Clocks, References and Timing"},{"location":"hardware/overview/#monitor-and-control","text":"flowchart TB B[FEM] S[SNAP] P[Raspberry Pi] D[Server] subgraph The Box P <-->|UART| B S <-->|GPIO| P end P <--->|1 GbE| D","title":"Monitor and Control"},{"location":"software/guix/","text":"Pipeline Modules and Guix Guix is a functional package manager and tool to instantiate and manage Unix-like operating systems. By functional, Guix defines packages through a purely functional deployment model in which every build is deterministic and is a pure function of the package's \"inputs\" or dependencies. This solves the problem of dependency hell and reproducability. For GReX, many of our software modules and components exist as forks of preexisting software as well as some custom code. To ensure all of these components work together in harmony, we'll host a guix channel that provides the build recipes for our software here . Most of this software, however, relies on the non-free CUDA runtime. As such, the user of these modules must add the proprietary HPC channel to their guix channels. ( cons ( channel ( name 'guix-hpc-non-free ) ( url \"https://gitlab.inria.fr/guix-hpc/guix-hpc-non-free.git\" )) %default-channels ) Note As a note, we are using non-free CUDA as to leverage high-performance preexisting code. CUDA, and non-free software in general, denies users the ability to study and modify it. This is detrimental to user freedom and to proper scientific review and experimentation. As such, we ask that you not share these modules widely as to encourage more open alternatives. Installation To start from a bare server, we need a few prerequisites. First, to actually build the install image, you need guix the guix binary installed. Installer isos will be provided, eventually. Clone the GReX Guix repo and run, this may take a while. $ guix system image --image-type = iso9660 system/install.scm After that, make an installation media, either CD or USB and boot into it. If you want to make a USB, simply $ sudo dd if = <the iso that was created> of = /dev/<your USB> status = progress bs = 32M && sync Once you boot into the installation media, select \"Install using the shell based process\" Partitions We'll partition the servers with UEFI, you can use any tool you like for this, I like cfdisk . You'll need to make a 512M vfat partition for EFI and then ext4 the rest. Then, format and mount the partitions mkfs.ext4 /dev/root_partition mkfs.fat -F 32 /dev/efi_system_partition mount /dev/root_partition /mnt mount --mkdir /dev/efi_system_partition /mnt/boot/efi Now we can setup the installation environment with herd start cow-store /mnt Initial Installation First, we need to grab the system configuration for this machine (assuming it exists). GReX servers we control will have their own configuration file. git clone https://github.com/GReX-Telescope/guix-grex First, we'll copy over the channels and update (this may take a while) mkdir -p ~/.config/guix cp guix-grex/channels.scm ~/.config/guix guix pull hash guix # This is necessary to ensure the updated profile path is active! Then initialize the system with guix system -L guix-grex init guix-grex/system/grex-01.scm /mnt Initial System Setup Now you can reboot and setup the users! First, we need to change the password. Login as root and passwd # For root passwd grex # For the GReX user Again, we need to pull down our channels list git clone https://github.com/GReX-Telescope/guix-grex ln -sf guix-grex/channels.scm ~/.config/guix/channels.scm And then one final pull guix pull We're ready to go!","title":"Guix"},{"location":"software/guix/#pipeline-modules-and-guix","text":"Guix is a functional package manager and tool to instantiate and manage Unix-like operating systems. By functional, Guix defines packages through a purely functional deployment model in which every build is deterministic and is a pure function of the package's \"inputs\" or dependencies. This solves the problem of dependency hell and reproducability. For GReX, many of our software modules and components exist as forks of preexisting software as well as some custom code. To ensure all of these components work together in harmony, we'll host a guix channel that provides the build recipes for our software here . Most of this software, however, relies on the non-free CUDA runtime. As such, the user of these modules must add the proprietary HPC channel to their guix channels. ( cons ( channel ( name 'guix-hpc-non-free ) ( url \"https://gitlab.inria.fr/guix-hpc/guix-hpc-non-free.git\" )) %default-channels ) Note As a note, we are using non-free CUDA as to leverage high-performance preexisting code. CUDA, and non-free software in general, denies users the ability to study and modify it. This is detrimental to user freedom and to proper scientific review and experimentation. As such, we ask that you not share these modules widely as to encourage more open alternatives.","title":"Pipeline Modules and Guix"},{"location":"software/guix/#installation","text":"To start from a bare server, we need a few prerequisites. First, to actually build the install image, you need guix the guix binary installed. Installer isos will be provided, eventually. Clone the GReX Guix repo and run, this may take a while. $ guix system image --image-type = iso9660 system/install.scm After that, make an installation media, either CD or USB and boot into it. If you want to make a USB, simply $ sudo dd if = <the iso that was created> of = /dev/<your USB> status = progress bs = 32M && sync Once you boot into the installation media, select \"Install using the shell based process\"","title":"Installation"},{"location":"software/guix/#partitions","text":"We'll partition the servers with UEFI, you can use any tool you like for this, I like cfdisk . You'll need to make a 512M vfat partition for EFI and then ext4 the rest. Then, format and mount the partitions mkfs.ext4 /dev/root_partition mkfs.fat -F 32 /dev/efi_system_partition mount /dev/root_partition /mnt mount --mkdir /dev/efi_system_partition /mnt/boot/efi Now we can setup the installation environment with herd start cow-store /mnt","title":"Partitions"},{"location":"software/guix/#initial-installation","text":"First, we need to grab the system configuration for this machine (assuming it exists). GReX servers we control will have their own configuration file. git clone https://github.com/GReX-Telescope/guix-grex First, we'll copy over the channels and update (this may take a while) mkdir -p ~/.config/guix cp guix-grex/channels.scm ~/.config/guix guix pull hash guix # This is necessary to ensure the updated profile path is active! Then initialize the system with guix system -L guix-grex init guix-grex/system/grex-01.scm /mnt","title":"Initial Installation"},{"location":"software/guix/#initial-system-setup","text":"Now you can reboot and setup the users! First, we need to change the password. Login as root and passwd # For root passwd grex # For the GReX user Again, we need to pull down our channels list git clone https://github.com/GReX-Telescope/guix-grex ln -sf guix-grex/channels.scm ~/.config/guix/channels.scm And then one final pull guix pull We're ready to go!","title":"Initial System Setup"},{"location":"software/overview/","text":"Software Overview Note I don't really understand this yet There are two primary components to the software stack in GReX. First, the SNAP board must be configured and setup to send voltage data to the server. After that, the pipeline software should take care of the rest. This pipeline will exist as a composition of Guix packages and potentially as a Guix System definition for the entire system. This is to ensure determinisim in builds and to reduce the potential of mis-configuration. Pipeline Overview flowchart TD A[SNAP] -->|UDP| B[Packet Capture] B -->|PSRDADA| C[Heimdall] C -->|\"?\"| D[\"?\"]","title":"Overview"},{"location":"software/overview/#software-overview","text":"Note I don't really understand this yet There are two primary components to the software stack in GReX. First, the SNAP board must be configured and setup to send voltage data to the server. After that, the pipeline software should take care of the rest. This pipeline will exist as a composition of Guix packages and potentially as a Guix System definition for the entire system. This is to ensure determinisim in builds and to reduce the potential of mis-configuration.","title":"Software Overview"},{"location":"software/overview/#pipeline-overview","text":"flowchart TD A[SNAP] -->|UDP| B[Packet Capture] B -->|PSRDADA| C[Heimdall] C -->|\"?\"| D[\"?\"]","title":"Pipeline Overview"},{"location":"software/pipeline/","text":"Pipeline","title":"Pipeline"},{"location":"software/pipeline/#pipeline","text":"","title":"Pipeline"},{"location":"software/snap/","text":"SNAP Configuration and Bringup The digital backend to the GReX system is a SNAP board from the CASPER group at Berkeley. This board contains the analog to digital converters and Xilinx FPGA to perform the digitization and F-engine components of the system. The setup and configuration of this board has seemingly never been well documented, so we'll try to make it as painless as possible here. Raspberry Pi TODO! Where do we get the magic image? Do we have to configure it? Bringup","title":"SNAP"},{"location":"software/snap/#snap-configuration-and-bringup","text":"The digital backend to the GReX system is a SNAP board from the CASPER group at Berkeley. This board contains the analog to digital converters and Xilinx FPGA to perform the digitization and F-engine components of the system. The setup and configuration of this board has seemingly never been well documented, so we'll try to make it as painless as possible here.","title":"SNAP Configuration and Bringup"},{"location":"software/snap/#raspberry-pi","text":"TODO! Where do we get the magic image? Do we have to configure it?","title":"Raspberry Pi"},{"location":"software/snap/#bringup","text":"","title":"Bringup"}]}